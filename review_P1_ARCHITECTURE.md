# Agio 项目代码审查 - P1 架构设计问题

## 概述
本文档列出系统架构设计层面的问题和改进方向，影响系统的可扩展性、可维护性和长期演进。

---

## 1. 架构分层问题

### 1.1 领域模型与基础设施耦合
**位置**: `agio/domain/models.py`, `agio/domain/adapters.py`

**问题描述**:
- `Step`、`Run` 等领域模型直接依赖 Pydantic
- `StepAdapter` 耦合了 LLM 的消息格式转换
- 领域层与基础设施层边界模糊

**影响**:
- 领域逻辑难以独立测试
- 更换存储或 LLM 接口需要修改核心模型
- 违反依赖倒置原则

**改进方向**:
- 将纯领域模型与 DTO/Schema 分离
- 领域层只依赖抽象接口，不依赖具体实现
- 使用 Repository 模式隔离持久化细节
- 参考 DDD 分层架构重构

---

### 1.2 循环依赖风险
**位置**: 多个模块间

**问题描述**:
- `config` 模块依赖 `tools`，`tools` 中的 RunnableTool 又依赖 `config`
- `agent` 依赖 `runtime`，`runtime` 的某些组件又需要了解 `agent` 的结构
- 虽然通过延迟导入缓解，但本质上是设计问题

**影响**:
- 模块职责不清晰
- 重构困难
- 测试时需要复杂的 mock

**改进方向**:
- 提取共享抽象到独立的 `protocols` 包
- 使用依赖注入容器统一管理依赖关系
- 重新审视模块职责，合并过度拆分的模块

---

### 1.3 Runnable 协议设计过于抽象
**位置**: `agio/runtime/protocol.py`

**问题描述**:
- `Runnable` 协议只定义了 `run()` 方法，缺少生命周期管理
- Agent 和 Workflow 的差异完全隐藏，但实际使用中需要区分
- 缺少明确的能力声明（如是否支持流式、是否有状态等）

**影响**:
- 调用方需要 `isinstance` 检查来判断具体类型
- 无法提前知道 Runnable 的能力和约束
- 扩展新类型的 Runnable 困难

**改进方向**:
- 增加 `capabilities()` 方法返回能力声明
- 定义生命周期钩子：`on_start()`, `on_complete()`, `on_error()`
- 考虑使用 Visitor 模式处理不同类型的 Runnable
- 或者承认差异，为 Agent 和 Workflow 定义不同接口

---

## 2. 状态管理问题

### 2.1 ExecutionContext 职责过重
**位置**: `agio/runtime/protocol.py`

**问题描述**:
- ExecutionContext 既包含执行身份（run_id, session_id）
- 又包含资源引用（wire）
- 还包含追踪信息（trace_id, span_id）
- 以及业务元数据（metadata）

**影响**:
- 单个对象承担过多职责
- 难以理解和维护
- 扩展时容易破坏现有代码

**改进方向**:
- 拆分为多个更小的上下文对象
  - `ExecutionIdentity`（身份信息）
  - `ExecutionResources`（资源引用）
  - `ObservabilityContext`（追踪信息）
- 使用组合模式而非大而全的类
- 考虑不可变模式避免状态混乱

---

### 2.2 WorkflowState 内存缓存可能无限增长
**位置**: `agio/workflow/state.py`

**问题描述**:
- WorkflowState 在内存中缓存所有节点输出
- 长时间运行或大输出的 Workflow 会导致内存占用激增
- 缺少缓存淘汰策略

**影响**:
- 内存泄漏风险
- 大规模并发时内存压力大

**改进方向**:
- 实现 LRU 缓存淘汰策略
- 大输出使用外部存储（如 Redis、S3）
- 添加内存使用监控和告警
- 考虑流式处理而非全量缓存

---

### 2.3 Session 持久化策略不一致
**位置**: `agio/storage/session/`

**问题描述**:
- Run 和 Step 分别保存，缺少统一的 Unit of Work
- 部分场景下 Run 保存失败但 Step 已写入
- SQLite 和 MongoDB 实现策略不统一

**影响**:
- 数据一致性难以保证
- 查询性能不可预测
- 难以实现复杂的事务需求

**改进方向**:
- 实现 Unit of Work 模式统一管理事务
- 定义清晰的持久化策略和一致性保证
- 考虑引入 CQRS 分离读写模型

---

## 3. 扩展性问题

### 3.1 ConfigSystem 扩展点不足
**位置**: `agio/config/system.py`

**问题描述**:
- 新增组件类型需要修改多处代码（CONFIG_CLASSES、Builder、Resolver）
- 缺少插件化机制
- 硬编码的类型判断（isinstance）

**影响**:
- 添加新组件类型成本高
- 不符合开闭原则
- 第三方扩展困难

**改进方向**:
- 实现插件注册机制
- 使用策略模式替代 isinstance 判断
- 提供扩展点文档和示例
- 考虑引入插件生命周期管理

---

### 3.2 LLM Provider 抽象不够统一
**位置**: `agio/llm/`

**问题描述**:
- 各 Provider 实现差异大（streaming 格式、错误处理等）
- 缺少统一的重试、限流、降级策略
- 新增 Provider 需要了解很多内部细节

**影响**:
- Provider 实现质量参差不齐
- 维护成本高
- 用户体验不一致

**改进方向**:
- 定义更细粒度的接口和约束
- 提供 BaseProvider 基类封装通用逻辑
- 实现统一的中间件机制（重试、限流、日志等）
- 添加 Provider 能力声明和自动测试

---

### 3.3 Tool 系统缺少分类和管理
**位置**: `agio/tools/`

**问题描述**:
- 所有工具平铺在 builtin 目录下
- 缺少工具分类、分组机制
- 无法按类别批量启用/禁用工具
- 工具依赖关系未显式声明

**影响**:
- 工具数量增多后难以管理
- 用户难以发现需要的工具
- 无法实现细粒度的权限控制

**改进方向**:
- 实现工具分类体系（按功能、风险等级分类）
- 提供工具集合（ToolSet）概念
- 支持工具依赖声明和自动安装
- 添加工具市场和版本管理

---

## 4. 性能优化方向

### 4.1 配置加载和构建性能
**位置**: `agio/config/`

**问题描述**:
- 每次启动都需要重新加载和构建所有组件
- 拓扑排序在配置多时可能成为瓶颈
- 缺少构建缓存机制

**影响**:
- 启动时间长
- 开发体验差
- 热重载响应慢

**改进方向**:
- 实现配置校验缓存
- 增量构建机制（只重建变更的组件）
- 使用持久化的依赖图
- 并行构建独立的组件

---

### 4.2 Step 查询性能优化
**位置**: `agio/storage/session/`

**问题描述**:
- `get_steps()` 方法支持多种过滤条件，但缺少索引优化
- 大 Session 场景下全量扫描性能差
- 缺少分页和游标支持

**影响**:
- 长对话历史加载慢
- 数据库压力大
- 用户体验差

**改进方向**:
- 添加复合索引：`(session_id, sequence)`, `(session_id, run_id)` 等
- 实现游标分页
- 添加查询缓存
- 考虑冷热数据分离存储

---

### 4.3 事件流传输优化
**位置**: `agio/runtime/wire.py`

**问题描述**:
- Wire 使用 asyncio.Queue，但没有背压控制
- 大量事件可能导致队列堆积
- 缺少事件批量传输机制

**影响**:
- 内存占用高
- 实时性受影响
- 可能触发 OOM

**改进方向**:
- 实现背压机制（慢消费者拖慢生产者）
- 支持事件批量传输减少网络开销
- 添加事件优先级和采样
- 考虑使用消息队列（Kafka/RabbitMQ）

---

## 5. 可测试性问题

### 5.1 依赖注入不彻底
**位置**: 全局

**问题描述**:
- 大量组件通过全局单例访问（ConfigSystem, ToolRegistry）
- 构造函数参数过多，缺少 Builder 模式
- 测试时需要大量 mock

**影响**:
- 单元测试困难
- 集成测试设置复杂
- 无法并行测试

**改进方向**:
- 使用依赖注入框架（如 injector, dependency-injector）
- 提供 TestFixture 和 TestBuilder
- 实现真正的组件隔离
- 添加契约测试

---

### 5.2 异步代码测试覆盖不足
**位置**: 多个异步模块

**问题描述**:
- 并发场景测试用例少
- 缺少超时、取消、竞态条件的测试
- Mock 异步依赖困难

**影响**:
- 并发 bug 难以发现
- 重构风险高

**改进方向**:
- 添加并发场景压测
- 使用 pytest-asyncio 完善异步测试
- 实现异步 Mock 工具库
- 添加混沌工程测试

---

## 6. 接口设计问题

### 6.1 API 路由设计不够 RESTful
**位置**: `agio/api/routes/`

**问题描述**:
- `/runnables/{id}/run` 使用 POST，但是幂等操作
- 部分路由同时支持 `query` 和 `message` 参数（向后兼容导致）
- 缺少统一的错误响应格式
- 版本控制缺失

**影响**:
- API 使用不直观
- 文档维护困难
- 向后兼容负担重

**改进方向**:
- 遵循 REST 最佳实践
- 引入 API 版本控制 `/v1/`, `/v2/`
- 定义统一的错误响应结构
- 添加 OpenAPI 规范自动生成

---

### 6.2 配置文件格式限制
**位置**: `agio/config/loader.py`

**问题描述**:
- 只支持 YAML 格式
- 缺少配置验证和提示
- 大型配置文件难以维护
- 无法引用外部配置

**影响**:
- 配置编写体验差
- 错误发现晚
- 配置复用困难

**改进方向**:
- 支持多种格式（YAML, TOML, JSON）
- 添加 JSON Schema 验证
- 实现配置模块化和继承
- 提供配置编辑器插件（VSCode）

---

## 7. 领域建模问题

### 7.1 Session 概念过载
**位置**: 全局

**问题描述**:
- Session 既是对话会话，又是工作流执行会话
- Session 与 Run 的关系不清晰
- 多 Agent 协作场景下 Session 边界模糊

**影响**:
- 概念混淆
- 难以实现复杂协作场景
- 数据模型受限

**改进方向**:
- 区分 `Conversation`（对话） 和 `ExecutionSession`（执行会话）
- 明确 Session 生命周期和边界
- 支持 Session 分叉和合并
- 参考 CQRS 模式重新设计

---

### 7.2 Step 模型职责混杂
**位置**: `agio/domain/models.py`

**问题描述**:
- Step 既包含业务数据（content, tool_calls）
- 又包含执行元数据（metrics, trace_id）
- 还包含工作流上下文（node_id, branch_key）

**影响**:
- 单个模型过于庞大
- 不同场景下只需要部分字段
- 查询和序列化开销大

**改进方向**:
- 拆分为 `CoreStep` + `ExecutionMetadata` + `WorkflowContext`
- 使用组合模式按需组装
- 定义视图模型（ViewModel）用于不同场景

---

## 8. 监控和运维

### 8.1 缺少健康检查机制
**位置**: `agio/api/routes/health.py`

**问题描述**:
- 健康检查只验证 API 响应，未检查依赖服务
- 缺少就绪检查（Readiness Probe）
- 无法判断服务真实可用性

**影响**:
- 负载均衡可能将流量打到异常实例
- 故障发现延迟
- 运维困难

**改进方向**:
- 实现深度健康检查（数据库、缓存等）
- 区分 Liveness 和 Readiness
- 添加降级开关
- 提供健康状态 API

---

### 8.2 配置热重载影响可用性
**位置**: `agio/config/hot_reload.py`

**问题描述**:
- 重载过程中服务不可用
- 缺少灰度发布机制
- 回滚困难

**影响**:
- 生产环境不敢使用热重载
- 配置变更需要重启服务

**改进方向**:
- 实现零停机热重载
- 支持配置灰度和 A/B 测试
- 添加配置版本管理和回滚
- 提供配置审计日志

---

## 优先级建议

**本季度重点**:
1. 1.1 领域模型重构
2. 3.1 ConfigSystem 插件化
3. 4.2 查询性能优化
4. 6.1 API 设计改进

**中长期规划**:
1. 架构分层重构
2. 状态管理优化
3. 可测试性提升
4. 运维能力增强
