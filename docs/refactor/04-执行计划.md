# 四、执行计划

> **原则**：每个 Phase 完成后运行测试验证，确保增量可用

## Phase 1：Metrics 统一 & 协议迁移（低风险） ✅ 已完成

**目标**：统一 Metrics 定义，迁移共享协议到 domain/

### Step 1.1：更新 domain/models.py

- 将 `AgentRunMetrics` 重命名为 `RunMetrics`
- 新增 `merge(other, mode="sequential"|"parallel")` 方法（参见 3.14.3 设计）
- 新增 `SessionMetrics` 类
- 确保 `StepMetrics` 包含完整字段
- 新增 `branches_executed` 字段（ParallelWorkflow 用）

### Step 1.2：创建 domain/protocol.py

- 从 `workflow/protocol.py` 移动 `Runnable`, `RunOutput`
- `RunOutput.metrics` 类型改为 `domain/models.py` 中的 `RunMetrics`
- **新增 `Runnable.runnable_type` 属性**（参见 3.3 设计）
  - Agent 返回 `"agent"`
  - BaseWorkflow 返回 `"workflow"`

### Step 1.3：更新 workflow/protocol.py

- 删除 `Runnable`, `RunOutput`, `RunMetrics` 定义
- 改为从 `domain/protocol.py` 重新导出

### Step 1.4：更新所有 import 路径

```bash
# 搜索并更新
grep -r "from agio.workflow.protocol import" --include="*.py"
```

### Step 1.5：验证测试
```bash
python -m pytest tests/ -v
```

---

## Phase 2：文件迁移（低风险） ✅ 已完成

**目标**：将 Workflow 专用组件移动到 workflow/ 目录

> **策略**：**不向后兼容**，直接更新所有 import 引用，避免遗留代码和死代码问题。

### Step 2.1：移动 WorkflowState

```bash
mv agio/runtime/workflow_state.py agio/workflow/state.py
```

### Step 2.2：移动 ContextResolver

```bash
mv agio/runtime/context_resolver.py agio/workflow/resolver.py
```

### Step 2.3：更新所有 import 引用（不保留重导出）

```bash
# 搜索所有引用
grep -r "from agio.runtime.workflow_state import" --include="*.py"
grep -r "from agio.runtime.context_resolver import" --include="*.py"
grep -r "from agio.runtime import.*WorkflowState" --include="*.py"
grep -r "from agio.runtime import.*ContextResolver" --include="*.py"

# 逐一更新为新路径
# from agio.runtime.workflow_state import WorkflowState
# → from agio.workflow.state import WorkflowState

# from agio.runtime.context_resolver import ContextResolver
# → from agio.workflow.resolver import ContextResolver
```

### Step 2.4：更新 __init__.py

- 更新 `agio/workflow/__init__.py`：添加 `WorkflowState`, `ContextResolver` 导出
- 更新 `agio/runtime/__init__.py`：**移除**已迁移组件（不保留重导出）

### Step 2.5：验证测试
```bash
python -m pytest tests/ -v
```

---

## Phase 3：依赖注入统一（中风险） ✅ 已完成

**目标**：Workflow 通过构造函数注入 SessionStore

### Step 3.1：修改 BaseWorkflow 构造函数

**文件**：`agio/workflow/base.py`

```python
def __init__(
    self,
    id: str,
    stages: list[WorkflowNode],
    session_store: SessionStore | None = None,  # ✅ 新增
):
    self._id = id
    self._nodes = stages
    self._session_store = session_store
    self._registry: dict[str, Runnable] = {}
```

### Step 3.2：修改 Workflow 子类

透传 `session_store` 到父类。

**文件**：
- `agio/workflow/pipeline.py`
- `agio/workflow/parallel.py`
- `agio/workflow/loop.py`

### Step 3.3：修改 WorkflowEngine

创建 Workflow 时传入 `session_store`。

### Step 3.4：修改 BaseWorkflow.run()

使用 `self._session_store` 创建 WorkflowState：

```python
async def run(self, input: str, *, context: ExecutionContext) -> RunOutput:
    state = WorkflowState(
        session_id=context.session_id,
        workflow_id=self._id,  # ← 使用 workflow_id 而非 run_id
        store=self._session_store,  # ← 使用构造函数注入的 store
    )
    # ...
```

### Step 3.5：清理 context.metadata 传递方式

删除 Workflow 中通过 `context.metadata["session_store"]` 获取的代码。

### Step 3.6：验证测试
```bash
python -m pytest tests/ -v
```

---

## Phase 4：StepRunner 重构（中风险） ✅ 已完成

**目标**：移除 StepRunner 中的 Run 管理逻辑和 Run 级别事件发射

### Step 4.1：移除 Run 创建逻辑

```python
# 删除
run = AgentRun(id=str(uuid4()), ...)

# 改为使用 context.run_id
run_id = context.run_id
```

### Step 4.2：移除 Run 保存逻辑

```python
# 删除
await self.session_store.save_run(run)
```

### Step 4.3：移除 Run 级别事件发射

```python
# 删除
await wire.write(ef.run_started(query))
await wire.write(ef.run_completed(...))
```

### Step 4.4：确保 RunOutput.metrics 正确返回

```python
return RunOutput(
    response=...,
    run_id=context.run_id,  # 使用外部 run_id
    metrics=RunMetrics(
        duration=...,
        total_tokens=...,
        ...
    ),
)
```

### Step 4.5：验证测试
```bash
python -m pytest tests/ -v
```

---

## Phase 5：创建 RunnableExecutor（中风险） ✅ 已完成

**目标**：创建 runtime/runnable_executor.py

### Step 5.1：创建 RunnableExecutor 类

```python
# agio/runtime/runnable_executor.py

class RunnableExecutor:
    """
    统一执行引擎 - 负责 Run 生命周期管理。
    
    职责：
    1. 创建 Run 记录
    2. 发射 Run 级别事件
    3. 委托给 runnable.run()
    4. 更新并保存 Run 记录
    """
    
    def __init__(self, store: SessionStore):
        self.store = store
    
    async def execute(
        self,
        runnable: Runnable,
        input: str,
        context: ExecutionContext,
    ) -> RunOutput:
        # 实现 Run 生命周期管理
        ...
```

### Step 5.2：更新 runtime/__init__.py 导出

添加 `RunnableExecutor` 导出。

---

## Phase 6：集成 RunnableExecutor（中风险） ✅ 已完成

**目标**：API 层和 Workflow 内部使用 RunnableExecutor

### Step 6.1：更新 Agent API 路由

**文件**：`agio/api/routes/agents.py` 或 `agio/api/routes/runnables.py`

```python
# 使用 RunnableExecutor
executor = RunnableExecutor(store=session_store)
result = await executor.execute(agent, input, context)
```

### Step 6.2：更新 Workflow API 路由

**文件**：`agio/api/routes/workflows.py`（如存在）

```python
# 使用 RunnableExecutor
executor = RunnableExecutor(store=session_store)
result = await executor.execute(workflow, input, context)
```

### Step 6.3：Workflow 内部使用 RunnableExecutor

**文件**：`agio/workflow/pipeline.py`、`parallel.py`、`loop.py`

```python
async def _execute(self, ...):
    executor = RunnableExecutor(store=self._session_store)
    
    for node in self._nodes:
        child_ctx = self._create_child_context(context, node)
        output = await executor.execute(runnable, node_input, child_ctx)
```

### Step 6.4：验证测试
```bash
python -m pytest tests/ -v
```

---

## Phase 7：Run 模型改造（中风险） ✅ 已完成

**目标**：用 Run 替代 AgentRun

### Step 7.1：重命名 AgentRun 为 Run

**文件**：`agio/domain/models.py`

- 删除 `AgentRun` 类
- 创建 `Run` 类，包含 `runnable_id`, `runnable_type` 字段
- 删除 `agent_id` 字段（不保留别名）

### Step 7.2：更新 SessionStore 接口

**文件**：`agio/providers/storage/base.py`

```python
class SessionStore(ABC):
    async def save_run(self, run: Run) -> None: ...
    async def get_run(self, run_id: str) -> Run | None: ...
    async def list_runs(
        self,
        session_id: str | None = None,
        runnable_id: str | None = None,
        runnable_type: str | None = None,
        parent_run_id: str | None = None,
        top_level_only: bool = False,
        limit: int = 20,
        offset: int = 0,
    ) -> list[Run]: ...
```

### Step 7.3：更新各 SessionStore 实现

- `agio/providers/storage/memory.py`
- `agio/providers/storage/mongo.py`（如存在）

### Step 7.4：更新所有引用

全局搜索 `AgentRun`，替换为 `Run`。

### Step 7.5：更新 API 响应

**文件**：`agio/api/routes/sessions.py`

- `RunResponse.agent_id` → `RunResponse.runnable_id`
- 新增 `RunResponse.runnable_type`

### Step 7.6：验证测试
```bash
python -m pytest tests/ -v --tb=short
```

---

## Phase 8：WorkflowState 查询优化（低风险）

**目标**：修复 Fork+Resume 场景下的查询问题

### Step 8.1：修改 WorkflowState 构造函数

**文件**：`agio/workflow/state.py`

```python
def __init__(
    self,
    session_id: str,
    workflow_id: str,  # ✅ 新增，替代 run_id
    store: "SessionStore",
):
```

### Step 8.2：修改 load_from_history 查询逻辑

```python
steps = await self._store.get_steps(
    session_id=self.session_id,
    workflow_id=self.workflow_id,  # ✅ 按 workflow_id 查询
    role="assistant",      # ✅ 只加载 assistant steps
    has_node_id=True,      # ✅ 只加载有 node_id 的（Workflow 产生的）
)
```

### Step 8.3：更新所有 WorkflowState 调用点

**文件**：
- `agio/workflow/pipeline.py`
- `agio/workflow/parallel.py`
- `agio/workflow/loop.py`
- `agio/workflow/base.py`

### Step 8.4：验证 Fork+Resume 场景

- [ ] Fork Workflow Session
- [ ] Resume 后 WorkflowState 正确加载历史
- [ ] 跳过已执行节点

---

## Phase 9：集成测试与验证（低风险）

### Step 9.1：单元测试

- 测试 `RunnableExecutor` 的 Run 生命周期管理
- 测试 `Run` 模型的持久化和查询
- 测试 `WorkflowState` 的幂等性检查
- 测试 Metrics 聚合

### Step 9.2：集成测试

- [ ] Agent 单独运行
- [ ] PipelineWorkflow 运行
- [ ] ParallelWorkflow 运行
- [ ] LoopWorkflow 运行
- [ ] 嵌套 Workflow（Workflow 包含 Workflow）
- [ ] 混合嵌套（Workflow 包含 Agent 和 Workflow）
- [ ] Resume 场景（中途失败后恢复）
- [ ] 深层嵌套（3层以上）

### Step 9.3：验证 Run 追踪

- [ ] 验证 `parent_run_id` 链路正确
- [ ] 验证 `runnable_type` 正确区分 Agent/Workflow
- [ ] 验证 metrics 正确聚合
- [ ] 验证事件发射层级正确

---

## Phase 执行顺序总结

| Phase | 内容 | 风险 | 前置依赖 |
|-------|------|------|----------|
| **1** | Metrics 统一 & 协议迁移 | 低 | 无 |
| **2** | 文件迁移（WorkflowState → workflow/） | 低 | Phase 1 |
| **3** | 依赖注入统一（Workflow 构造函数注入） | 中 | 无 |
| **4** | StepRunner 重构（移除 Run 管理 + 事件发射） | 中 | Phase 1 |
| **5** | 创建 RunnableExecutor | 中 | Phase 1, 4 |
| **6** | 集成 RunnableExecutor（API + Workflow 内部） | 中 | Phase 5 |
| **7** | Run 模型改造（AgentRun → Run） | 中 | Phase 5 |
| **8** | WorkflowState 查询优化（run_id → workflow_id） | 低 | Phase 2 |
| **9** | 集成测试与验证 | 低 | 全部 |

---

## Phase 10：Step 模型扩展（低风险）

**目标**：扩展 Step 模型支持 ParallelWorkflow 和 LoopWorkflow

### Step 10.1：扩展 Step 模型

**文件**：`agio/domain/models.py`

```python
class Step(BaseModel):
    # ... 现有字段 ...
    
    # 新增字段
    iteration: int | None = None  # LoopWorkflow 迭代次数（从 1 开始）
    # branch_key 已存在，用于 ParallelWorkflow
```

### Step 10.2：扩展 ExecutionContext

**文件**：`agio/runtime/execution_context.py`

```python
class ExecutionContext:
    # ... 现有字段 ...
    iteration: int | None = None  # 当前循环迭代
    seq_start: int | None = None  # 预分配的 seq 起始值（并行执行）
    
    def with_iteration(self, iteration: int) -> "ExecutionContext":
        """创建带有迭代信息的新上下文"""
        ...
```

### Step 10.3：更新 StepRunner

**文件**：`agio/runtime/runner.py`

- 创建 Step 时，从 `context.iteration` 获取迭代信息
- 从 `context.metadata.get("seq_start")` 获取预分配的 seq 起始值

### Step 10.4：验证测试

```bash
python -m pytest tests/ -v -k "step or workflow"
```

---

## Phase 11：ParallelWorkflow seq 分配优化（中风险）

**目标**：实现并行分支的 seq 预分配

### Step 11.1：添加获取 max_seq 方法

**文件**：`agio/providers/storage/base.py`

```python
class SessionStore(ABC):
    async def get_max_sequence(self, session_id: str) -> int:
        """获取 session 中的最大 sequence 值"""
        ...
```

### Step 11.2：实现各 SessionStore

**文件**：
- `agio/providers/storage/memory.py`
- `agio/providers/storage/mongo.py`

### Step 11.3：更新 ParallelWorkflow

**文件**：`agio/workflow/parallel.py`

```python
class ParallelWorkflow(BaseWorkflow):
    SEQ_INTERVAL = 100  # 每个分支预留的 seq 区间大小

    async def _execute(self, input: str, *, context: ExecutionContext) -> RunOutput:
        # 获取当前 max_seq
        current_max_seq = await self._get_session_max_seq(context.session_id)
        
        # 为每个分支预分配 seq 起始值
        branch_seq_starts = {
            branch.id: current_max_seq + 1 + i * self.SEQ_INTERVAL
            for i, branch in enumerate(self.nodes)
        }
        
        async def execute_branch(branch: WorkflowNode) -> BranchResult:
            child_ctx = self._create_child_context(context, branch)
            child_ctx = child_ctx.with_metadata(
                branch_key=branch.id,
                seq_start=branch_seq_starts[branch.id],
            )
            return await runnable.run(node_input, context=child_ctx)
```

### Step 11.4：更新 Metrics 聚合

使用 `merge(other, mode="parallel")` 替代简单的 sum

### Step 11.5：验证测试

```bash
python -m pytest tests/workflow/test_parallel.py -v
```

---

## Phase 12：LoopWorkflow iteration 支持（中风险）

**目标**：实现循环迭代的 Step 标记和幂等性

### Step 12.1：更新 LoopWorkflow

**文件**：`agio/workflow/loop.py`

```python
async def _execute(self, input: str, *, context: ExecutionContext) -> RunOutput:
    iteration = 0
    while iteration < self.max_iterations:
        iteration += 1
        
        for node in self.nodes:
            child_ctx = self._create_child_context(context, node)
            child_ctx = child_ctx.with_iteration(iteration)
            
            result = await runnable.run(node_input, context=child_ctx)
```

### Step 12.2：更新 WorkflowState 幂等性键

**文件**：`agio/workflow/state.py`

```python
def _get_output_key(self, node_id: str, iteration: int | None) -> str:
    if iteration:
        return f"{node_id}:iter_{iteration}"
    return node_id
```

### Step 12.3：验证测试

```bash
python -m pytest tests/workflow/test_loop.py -v
```

---

## Phase 13：Fork/Resume 场景验证（低风险）

**目标**：验证各 Workflow 类型的 Fork/Resume 行为

### Step 13.1：PipelineWorkflow Fork/Resume 测试

- [ ] Fork 到中间节点
- [ ] Resume 后跳过已完成节点
- [ ] 验证 WorkflowState 正确加载历史

### Step 13.2：ParallelWorkflow Fork/Resume 测试

- [ ] Fork 到分支中间
- [ ] Resume 后重新执行未完成分支
- [ ] 验证分支级别原子性

### Step 13.3：LoopWorkflow Fork/Resume 测试

- [ ] Fork 到迭代中间
- [ ] Resume 后从该迭代继续
- [ ] 验证迭代级别幂等性

### Step 13.4：深层嵌套测试

- [ ] Workflow 嵌套 Workflow 的 Fork/Resume
- [ ] 混合嵌套（Pipeline 包含 Parallel 包含 Loop）

---

## Phase 执行顺序总结（更新）

| Phase | 内容 | 风险 | 前置依赖 |
|-------|------|------|----------|
| **1** | Metrics 统一 & 协议迁移 | 低 | 无 |
| **2** | 文件迁移（WorkflowState → workflow/） | 低 | Phase 1 |
| **3** | 依赖注入统一（Workflow 构造函数注入） | 中 | 无 |
| **4** | StepRunner 重构（移除 Run 管理 + 事件发射） | 中 | Phase 1 |
| **5** | 创建 RunnableExecutor | 中 | Phase 1, 4 |
| **6** | 集成 RunnableExecutor（API + Workflow 内部） | 中 | Phase 5 |
| **7** | Run 模型改造（AgentRun → Run） | 中 | Phase 5 |
| **8** | WorkflowState 查询优化（run_id → workflow_id） | 低 | Phase 2 |
| **9** | 集成测试与验证 | 低 | 全部 |
| **10** | Step 模型扩展（iteration 字段） | 低 | Phase 1 |
| **11** | ParallelWorkflow seq 分配优化 | 中 | Phase 10 |
| **12** | LoopWorkflow iteration 支持 | 中 | Phase 10 |
| **13** | Fork/Resume 场景验证 | 低 | Phase 8, 11, 12 |
