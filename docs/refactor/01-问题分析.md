# 一、现状问题总结

基于两份架构 Review 报告和当前代码分析，识别出以下核心问题：

## 1.1 执行层抽象不统一

| 维度 | Agent | Workflow | 问题影响 |
|------|-------|----------|----------|
| **执行层** | `StepRunner` | 无（直接在 `_execute` 中） | Workflow 缺少统一的生命周期管理 |
| **Run 元数据** | 创建 `AgentRun` | 无 | Workflow 执行历史无法追踪 |
| **Resume 机制** | `resume_from_step` 系列方法 | 仅依赖幂等性检查 | 两套不同的恢复机制 |

**代码现状**：
- Agent: `Agent.run()` → `StepRunner.run()` → `StepExecutor.execute()`
- Workflow: `BaseWorkflow.run()` → `PipelineWorkflow._execute()` (直接执行)

## 1.2 依赖注入方式不一致

**Agent 方式**（正确）：
```python
# agent.py
def __init__(self, ..., session_store=None):
    self.session_store = session_store

# 使用时
runner = StepRunner(agent=self, session_store=self.session_store)
```

**Workflow 方式**（有问题）：
```python
# pipeline.py
session_store = context.metadata.get("session_store")
if session_store is None:
    raise ValueError("SessionStore required...")
```

**问题**：
- 类型不安全（metadata 是 dict）
- 隐式依赖，容易遗漏
- 违反设计原则（metadata 应用于可选元数据）

## 1.3 模块职责边界混乱

**当前目录结构问题**：
```
agio/runtime/
├── runner.py           # Agent 专用
├── executor.py         # Agent 专用
├── workflow_state.py   # ❌ Workflow 专用，但放在 runtime
├── context_resolver.py # ❌ Workflow 专用，但放在 runtime
├── execution_context.py # 通用
└── ...
```

`WorkflowState` 和 `ContextResolver` 是 **Workflow 专用**组件，却放在 `runtime/` 目录，导致：
- 概念混淆：`runtime` 定位不清（是 Agent 专用还是通用？）
- 依赖关系混乱：`workflow/` 依赖 `runtime/workflow_state.py`

## 1.4 状态管理机制分裂

| 维度 | Agent | Workflow |
|------|-------|----------|
| **状态载体** | Steps（持久化） | WorkflowState（内存缓存）+ Steps |
| **状态查询** | 通过 `run_id` 过滤 | 先查缓存，再查 DB |
| **特点** | 纯持久化 | 混合模式 |
