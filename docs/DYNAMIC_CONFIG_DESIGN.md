# 动态配置系统设计方案

## 📋 目录

1. [设计目标](#设计目标)
2. [核心架构](#核心架构)
3. [关键组件设计](#关键组件设计)
4. [配置更新流程](#配置更新流程)
5. [必须避免的坑](#必须避免的坑)
6. [关键优化思路](#关键优化思路)
7. [API 设计](#api-设计)
8. [实现计划](#实现计划)

---

## 设计目标

### 核心需求

1. **统一配置管理** - 所有组件（Agent、Model、Tool、Memory、Knowledge、Hook）都基于 YAML 配置
2. **动态更新** - 配置修改后实时生效，无需重启服务
3. **配置持久化** - 配置存储到数据库，支持版本管理
4. **API 驱动** - 提供 RESTful API 管理配置
5. **依赖管理** - 自动处理组件间的依赖关系
6. **热重载** - 配置更新后自动重建相关组件

### 设计原则

- **单一职责** - 配置管理、组件构建、依赖解析分离
- **最小影响** - 配置更新只影响相关组件，不影响运行中的任务
- **类型安全** - 使用 Pydantic 保证配置验证
- **可观测性** - 配置变更全程可追踪

---

## 核心架构

### 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                     Configuration API                        │
│  POST /api/config/{type}/{name}  - 创建/更新配置            │
│  GET  /api/config/{type}/{name}  - 获取配置                 │
│  DELETE /api/config/{type}/{name} - 删除配置                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                   ConfigManager (核心)                       │
│  - 配置 CRUD                                                 │
│  - 配置验证                                                  │
│  - 配置持久化                                                │
│  - 变更通知                                                  │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                 ComponentRegistry (注册中心)                 │
│  - 组件注册/注销                                             │
│  - 依赖图管理                                                │
│  - 组件生命周期                                              │
│  - 热重载协调                                                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                ComponentFactory (工厂)                       │
│  - 根据配置构建组件                                          │
│  - 依赖注入                                                  │
│  - 组件初始化                                                │
└─────────────────────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                  Component Instances                         │
│  Agent | Model | Tool | Memory | Knowledge | Hook           │
└─────────────────────────────────────────────────────────────┘
```

### 数据流

```
配置更新请求
    │
    ▼
ConfigManager 验证配置
    │
    ▼
保存到数据库 (ConfigRepository)
    │
    ▼
触发变更事件 (ConfigChangeEvent)
    │
    ▼
ComponentRegistry 接收事件
    │
    ▼
分析依赖影响 (DependencyGraph)
    │
    ▼
标记受影响组件为 "待重建"
    │
    ▼
等待运行中任务完成 (GracefulShutdown)
    │
    ▼
ComponentFactory 重建组件
    │
    ▼
更新 Registry 中的实例
    │
    ▼
新请求使用新配置
```

---

## 关键组件设计

详细的组件设计请参考后续章节。

---

## 配置更新流程

### 完整流程

1. **API 接收请求** - POST /api/config/agent/customer_support
2. **ConfigManager 验证** - Pydantic 验证 + 依赖检查
3. **保存到数据库** - MongoDB 持久化 + 版本记录
4. **发布变更事件** - ConfigChangeEvent
5. **分析依赖影响** - DependencyGraph 计算受影响组件
6. **标记待重建** - ComponentState.PENDING_REBUILD
7. **等待任务完成** - 优雅等待运行中任务
8. **重建组件** - 按拓扑顺序重建
9. **更新状态** - ComponentState.ACTIVE
10. **新配置生效** - 新请求使用新组件

### 关键时序

- T0: 配置更新请求到达
- T1: 配置验证完成（~10ms）
- T2: 保存到数据库（~50ms）
- T3: 事件发布（~1ms）
- T4: 依赖分析完成（~5ms）
- T5: 等待任务完成（0-30s）
- T6: 组件重建（~100ms）
- T7: 新配置生效

**总耗时**: ~200ms + 等待时间

---

## 必须避免的坑

### 1. 并发更新冲突

**问题**: 多个配置同时更新导致不一致

**解决**: 使用分布式锁，锁定配置名称

### 2. 循环依赖

**问题**: Agent A 依赖 Tool B，Tool B 依赖 Agent A

**解决**: 添加节点前检测循环，使用 DFS 算法

### 3. 运行中任务中断

**问题**: 配置更新强制终止任务

**解决**: 优雅等待，设置超时（30s），任务计数追踪

### 4. 依赖不存在

**问题**: 配置引用不存在的组件

**解决**: 保存前验证所有依赖存在性

### 5. 配置回滚失败

**问题**: 更新失败无法回滚

**解决**: 保存旧配置，异常时自动回滚

### 6. 内存泄漏

**问题**: 旧组件实例未清理

**解决**: 实现 cleanup 方法，显式清理资源

### 7. 配置版本冲突

**问题**: 多客户端基于旧版本修改

**解决**: 乐观锁，检查版本号

---

## 关键优化思路

### 1. 配置缓存

**目标**: 减少数据库查询

**方案**: 内存缓存 + TTL + 更新时清除

### 2. 增量重建

**目标**: 只重建变化的部分

**方案**: 精确依赖分析，最小化重建范围

### 3. 异步重建

**目标**: 不阻塞 API 响应

**方案**: 后台任务队列，状态轮询接口

### 4. 配置预热

**目标**: 启动时快速加载

**方案**: 批量加载 + 并行构建

### 5. 依赖图缓存

**目标**: 加速影响分析

**方案**: 预计算依赖关系，增量更新

### 6. 配置验证缓存

**目标**: 避免重复验证

**方案**: 缓存验证结果，配置哈希

### 7. 分布式协调

**目标**: 多实例配置同步

**方案**: Redis Pub/Sub + 版本号

---

## API 设计

详细 API 设计请参考 `API_DESIGN.md`

---

## 实现计划

详细实现计划请参考 `IMPLEMENTATION_PLAN.md`
